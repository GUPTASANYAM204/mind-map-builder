import React, { useState, useEffect, useRef } from 'react';
import { Stage, Layer, Group, Arrow, Path } from 'react-konva';
import type { KonvaEventObject } from 'konva/lib/Node';
import Node from './Node';
import type { NodeShape, NodeColorScheme } from './Node';
import { motion, AnimatePresence } from 'framer-motion';
import { generateLearningPath } from '../services/aiService';
import type { LearningPathNode } from '../services/aiService';

// Theme type definition
export type ThemeMode = 'dark' | 'vibrant';

// Define types for our mind map data
interface NodeData {
  id: string;
  text: string;
  children: NodeData[];
  x?: number;
  y?: number;
  isCollapsed?: boolean;
  shape?: NodeShape;
  colorScheme?: NodeColorScheme;
  description?: string;
  resources?: string[];
  timeEstimate?: string;
}

interface CanvasProps {
  mindMap: NodeData;
  setMindMap: React.Dispatch<React.SetStateAction<NodeData | null>>;
  theme?: ThemeMode;
  setTheme?: React.Dispatch<React.SetStateAction<ThemeMode>>;
}

interface ContextMenuState {
  visible: boolean;
  x: number;
  y: number;
  nodeId: string | null;
}

interface ModalState {
  visible: boolean;
  nodeId: string | null;
  x: number;
  y: number;
}

const Canvas: React.FC<CanvasProps> = ({ mindMap, setMindMap, theme = 'dark', setTheme }) => {
  const [scale, setScale] = useState(1);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [contextMenu, setContextMenu] = useState<ContextMenuState>({
    visible: false,
    x: 0,
    y: 0,
    nodeId: null,
  });
  const [modal, setModal] = useState<ModalState>({
    visible: false,
    nodeId: null,
    x: 0,
    y: 0,
  });
  const [newNodeText, setNewNodeText] = useState('');
  const [selectedShape, setSelectedShape] = useState<NodeShape>('rectangle');
  const [selectedColorScheme] = useState<NodeColorScheme>('dark');
  const [showSettings, setShowSettings] = useState(false);
  const [learningPath, setLearningPath] = useState<LearningPathNode[] | null>(null);
  const [showLearningPath, setShowLearningPath] = useState(false);
  const stageRef = useRef<any>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // Update stage dimensions on window resize
  useEffect(() => {
    const handleResize = () => {
      if (stageRef.current && containerRef.current) {
        stageRef.current.width(containerRef.current.offsetWidth);
        stageRef.current.height(containerRef.current.offsetHeight);
      }
    };

    handleResize();
    window.addEventListener('resize', handleResize);
    
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  // Handle wheel events for zooming
  const handleWheel = (e: KonvaEventObject<WheelEvent>) => {
    e.evt.preventDefault();
    
    const scaleBy = 1.1;
    const stage = stageRef.current;
    const oldScale = stage.scaleX();
    
    const pointerPosition = stage.getPointerPosition();
    const mousePointTo = {
      x: (pointerPosition.x - stage.x()) / oldScale,
      y: (pointerPosition.y - stage.y()) / oldScale,
    };
    
    const newScale = e.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;
    
    setScale(newScale);
    setPosition({
      x: pointerPosition.x - mousePointTo.x * newScale,
      y: pointerPosition.y - mousePointTo.y * newScale,
    });
  };

  // Find a node by ID in the mind map tree
  const findNodeById = (nodes: NodeData[], id: string): NodeData | null => {
    for (const node of nodes) {
      if (node.id === id) {
        return node;
      }
      if (node.children.length > 0) {
        const foundNode = findNodeById(node.children, id);
        if (foundNode) {
          return foundNode;
        }
      }
    }
    return null;
  };

  // Update a node's position in the mind map tree
  const updateNodePosition = (nodeId: string, x: number, y: number) => {
    setMindMap((prevMap) => {
      if (!prevMap) return prevMap;
      
      const updateNode = (node: NodeData): NodeData => {
        if (node.id === nodeId) {
          return { ...node, x, y };
        }
        
        if (node.children.length > 0) {
          return {
            ...node,
            children: node.children.map(updateNode),
          };
        }
        
        return node;
      };
      
      return updateNode(prevMap);
    });
  };

  // Handle context menu for a node
  const handleContextMenu = (e: KonvaEventObject<MouseEvent>, nodeId: string) => {
    e.evt.preventDefault();
    const stage = stageRef.current;
    const pointerPosition = stage.getPointerPosition();
    
    setContextMenu({
      visible: true,
      x: pointerPosition.x,
      y: pointerPosition.y,
      nodeId,
    });
  };

  // Close the context menu
  const closeContextMenu = () => {
    setContextMenu({
      visible: false,
      x: 0,
      y: 0,
      nodeId: null,
    });
  };

  // Handle expanding a node
  const handleExpand = () => {
    if (!contextMenu.nodeId) return;
    
    closeContextMenu();
    
    const stage = stageRef.current;
    const pointerPosition = stage.getPointerPosition();
    
    setModal({
      visible: true,
      nodeId: contextMenu.nodeId,
      x: pointerPosition.x,
      y: pointerPosition.y,
    });
  };

  // Handle collapsing a node
  const handleCollapse = () => {
    if (!contextMenu.nodeId) return;
    
    setMindMap((prevMap) => {
      if (!prevMap) return prevMap;
      
      const updateNode = (node: NodeData): NodeData => {
        if (node.id === contextMenu.nodeId) {
          return { ...node, isCollapsed: !node.isCollapsed };
        }
        
        if (node.children.length > 0) {
          return {
            ...node,
            children: node.children.map(updateNode),
          };
        }
        
        return node;
      };
      
      return updateNode(prevMap);
    });
    
    closeContextMenu();
  };

  // Handle deleting a node
  const handleDelete = () => {
    if (!contextMenu.nodeId || contextMenu.nodeId === 'root') return;
    
    setMindMap((prevMap) => {
      if (!prevMap) return prevMap;
      
      const deleteNode = (node: NodeData): NodeData => {
        return {
          ...node,
          children: node.children
            .filter((child) => child.id !== contextMenu.nodeId)
            .map(deleteNode),
        };
      };
      
      return deleteNode(prevMap);
    });
    
    closeContextMenu();
  };

  // Close the modal
  const closeModal = () => {
    setModal({
      visible: false,
      nodeId: null,
      x: 0,
      y: 0,
    });
    setNewNodeText('');
  };

  // Reorganize the entire mind map in a B-tree structure
  const reorganizeMindMap = () => {
    setMindMap((prevMap) => {
      if (!prevMap) return prevMap;
      
      // Create a deep copy of the mind map to work with
      const newMap = JSON.parse(JSON.stringify(prevMap));
      
      // Calculate the available canvas dimensions
      const canvasWidth = window.innerWidth * 2; // Use double the window width for scrolling
      const canvasHeight = window.innerHeight * 2; // Use double the window height for scrolling
      
      // B-tree style layout constants
      const nodeWidth = 250; // Width of each node
      const nodeHeight = 80; // Height of each node
      const horizontalSpacing = 350; // Space between siblings
      const verticalSpacing = 250; // Base vertical spacing between levels
      
      // Function to update node positions in a B-tree structure
      const updateNodePositions = (node: NodeData, depth = 0, index = 0, siblingCount = 1, parentX = canvasWidth / 2, parentY = 100): void => {
        // Root node is placed at the top center
        if (depth === 0) {
          node.x = canvasWidth / 2;
          node.y = 100;
        } else {
          // Calculate the total width needed for all siblings at this level
          const totalWidth = siblingCount * nodeWidth + (siblingCount - 1) * horizontalSpacing;
          
          // Calculate the starting X position for the first sibling
          const startX = parentX - (totalWidth / 2) + (nodeWidth / 2);
          
          // Position this node based on its index among siblings
          node.x = startX + index * (nodeWidth + horizontalSpacing);
          
          // Increase vertical spacing for deeper levels
          const levelSpacing = verticalSpacing + (depth * 50);
          node.y = parentY + nodeHeight + levelSpacing;
        }
        
        // Recursively position all children
        const childCount = node.children.length;
        for (let i = 0; i < childCount; i++) {
          updateNodePositions(node.children[i], depth + 1, i, childCount, node.x, node.y);
        }
      };
      
      // Update all node positions to create a proper B-tree structure
      updateNodePositions(newMap);
      
      // Add sequence numbers to node text if they don't already have them
      const addSequenceNumbers = (node: NodeData, parentPath = ''): void => {
        // Skip the root node
        if (parentPath !== '') {
          // Only add sequence number if it doesn't already have one
          if (!node.text.match(/^\d+\.\s/)) {
            const parts = parentPath.split('.');
            const lastPart = parts[parts.length - 1];
            node.text = `${lastPart}. ${node.text}`;
          }
        }
        
        // Process children with their own sequence numbers
        node.children.forEach((child, index) => {
          const childPath = parentPath === '' ? `${index + 1}` : `${parentPath}.${index + 1}`;
          addSequenceNumbers(child, childPath);
        });
      };
      
      // Add sequence numbers to all nodes
      addSequenceNumbers(newMap);
      
      return newMap;
    });
  };

  // Handle adding a manual node
  const handleAddManualNode = () => {
    if (!modal.nodeId || !newNodeText.trim()) return;
    
    const newNodeId = `node-${Date.now()}`;
    
    setMindMap((prevMap) => {
      if (!prevMap) return prevMap;
      
      const updateNode = (node: NodeData): NodeData => {
        if (node.id === modal.nodeId) {
          // Get parent node
          const parentNode = findNodeById([prevMap], modal.nodeId);
          if (!parentNode) return node;
          
          // Add sequence number to show order of steps
          const childCount = node.children.length;
          const sequenceNumber = childCount + 1;
          
          // Create new node with sequence number
          const newNode = {
            id: newNodeId,
            text: `${sequenceNumber}. ${newNodeText}`,
            children: [],
            shape: selectedShape,
            colorScheme: selectedColorScheme,
            description: `Step ${childCount + 1} in the process`
          };
          
          // Add the new node to children
          const updatedNode = {
            ...node,
            isCollapsed: false,
            children: [...node.children, newNode],
          };
          
          return updatedNode;
        }
        
        if (node.children.length > 0) {
          return {
            ...node,
            children: node.children.map(updateNode),
          };
        }
        
        return node;
      };
      
      // Update the mind map with the new node
      const updatedMap = updateNode(prevMap);
      
      // Reorganize the entire mind map to ensure proper B-tree structure
      setTimeout(() => reorganizeMindMap(), 10);
      
      return updatedMap;
    });
    
    closeModal();
  };

  // Handle generating AI nodes using our AI service
  const handleGenerateAINodes = async () => {
    if (!modal.nodeId) return;
    
    // Find the node to generate subtopics for
    const parentNode = findNodeById([mindMap], modal.nodeId || '');
    if (!parentNode) return;
    
    try {
      // Import dynamically to avoid issues with SSR
      const { generateSubtopics } = await import('../services/aiService');
      const subtopics = await generateSubtopics(parentNode.text);
      
      // Also fetch a learning path if this is the root node
      if (parentNode.id === 'root' && !learningPath) {
        try {
          const path = await generateLearningPath(parentNode.text);
          setLearningPath(path);
        } catch (error) {
          console.error('Error generating learning path:', error);
        }
      }
      
      setMindMap((prevMap) => {
        if (!prevMap) return prevMap;
        
        const updateNode = (node: NodeData): NodeData => {
          if (node.id === modal.nodeId) {
            // Calculate positions for the new nodes in a tree structure
            const childCount = node.children.length;
            
            // Create new AI-generated nodes with sequence numbers
            const newChildren = subtopics.map((topic, index) => {
              const sequenceNumber = childCount + index + 1;
              
              return {
                id: `node-${Date.now()}-${index}`,
                text: `${sequenceNumber}. ${topic}`,
                children: [],
                shape: selectedShape,
                colorScheme: selectedColorScheme,
                description: `Step ${childCount + index + 1} in the process`
              };
            });
            
            // Add the new nodes to children
            const updatedNode = {
              ...node,
              isCollapsed: false,
              children: [...node.children, ...newChildren],
            };
            
            return updatedNode;
          }
          
          if (node.children.length > 0) {
            return {
              ...node,
              children: node.children.map(updateNode),
            };
          }
          
          return node;
        };
        
        // Update the mind map with the new AI-generated nodes
        const updatedMap = updateNode(prevMap);
        
        // Reorganize the entire mind map to ensure proper B-tree structure
        setTimeout(() => reorganizeMindMap(), 10);
        
        return updatedMap;
      });
    } catch (error) {
      console.error('Error generating AI nodes:', error);
      // Could add a toast notification here in a more complete implementation
    }
    
    closeModal();
  };

  // Render the mind map nodes recursively
  const renderNodes = (node: NodeData) => {
    if (!node) return null;
    
    return (
      <Group key={node.id}>
        <Node
          id={node.id}
          text={node.text}
          x={node.x || 0}
          y={node.y || 0}
          shape={node.shape || selectedShape}
          colorScheme={node.colorScheme || selectedColorScheme}
          onDragEnd={(x: number, y: number) => updateNodePosition(node.id, x, y)}
          onContextMenu={(e: KonvaEventObject<MouseEvent>) => handleContextMenu(e, node.id)}
        />
        
        {!node.isCollapsed && node.children.map((child) => {
          // Calculate the start and end points for the connecting line
          const parentX = node.x || 0;
          const parentY = node.y || 0;
          const childX = child.x || 0;
          const childY = child.y || 0;
          
          // Determine node dimensions based on shape
          const parentWidth = node.shape === 'square' ? 120 : 180;
          const parentHeight = 80;
          const childWidth = child.shape === 'square' ? 120 : 180;
          // Node dimensions for calculations
          const childHeight = 80; // Used for vertical positioning calculations
          
          // Calculate connection points for a tree structure
          // Start from the bottom center of the parent
          const startX = parentX + parentWidth / 2;
          const startY = parentY + parentHeight;
          
          // End at the top center of the child
          const endX = childX + childWidth / 2;
          const endY = childY;
          
          // Calculate the vertical midpoint for the curved path
          // Using childHeight to determine the curve control points
          const verticalMidpoint = startY + (endY - startY - childHeight) / 2;
          
          return (
            <React.Fragment key={child.id}>
              {/* Draw curved connecting line with arrow */}
              <Group>
                {/* Create a curved path for the connection */}
                <Path
                  data={`M${startX},${startY} C${startX},${verticalMidpoint} ${endX},${verticalMidpoint} ${endX},${endY}`}
                  stroke={theme === 'dark' ? 'var(--dark-node-3)' : 'var(--vibrant-node-3)'}
                  strokeWidth={2}
                  dash={[5, 2]}
                />
                {/* Add arrow at the end of the curved path */}
                <Arrow
                  points={[endX, endY, endX, endY - 10]}
                  pointerLength={5}
                  pointerWidth={5}
                  fill={theme === 'dark' ? 'var(--dark-node-3)' : 'var(--vibrant-node-3)'}
                  stroke={theme === 'dark' ? 'var(--dark-node-3)' : 'var(--vibrant-node-3)'}
                  strokeWidth={2}
                />
              </Group>
              {renderNodes(child)}
            </React.Fragment>
          );
        })}
      </Group>
    );
  };

  // Toggle settings panel
  const toggleSettings = () => {
    setShowSettings(!showSettings);
  };

  // Toggle learning path panel
  const toggleLearningPath = () => {
    setShowLearningPath(!showLearningPath);
  };

  // Generate learning path if it doesn't exist
  const handleGenerateLearningPath = async () => {
    if (showLearningPath && !learningPath && mindMap) {
      try {
        const path = await generateLearningPath(mindMap.text);
        setLearningPath(path);
      } catch (error) {
        console.error('Error generating learning path:', error);
      }
    }
  };

  // Call reorganizeMindMap when the component mounts or when mindMap changes
  useEffect(() => {
    if (mindMap) {
      reorganizeMindMap();
    }
  }, []);

  return (
    <div className="relative h-full w-full" ref={containerRef}>
      {/* Settings Panel */}
      {showSettings && (
        <div 
          className="absolute top-4 right-4 bg-white p-4 rounded-lg shadow-lg z-20"
          style={{ 
            backgroundColor: theme === 'dark' ? 'var(--dark-node-1)' : 'white',
            color: theme === 'dark' ? 'white' : 'inherit'
          }}
        >
          <h3 className="text-lg font-semibold mb-4">Settings</h3>
          
          <div className="mb-4">
            <h4 className="font-medium mb-2">Theme</h4>
            <div className="flex space-x-2">
              <button
                className={`px-3 py-1 rounded-lg ${theme === 'dark' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setTheme('dark')}
              >
                Dark
              </button>
              <button
                className={`px-3 py-1 rounded-lg ${theme === 'vibrant' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setTheme('vibrant')}
              >
                Vibrant
              </button>
            </div>
          </div>
          
          <div className="mb-4">
            <h4 className="font-medium mb-2">Node Shape</h4>
            <div className="flex space-x-2">
              <button
                className={`px-3 py-1 rounded-lg ${selectedShape === 'rectangle' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setSelectedShape('rectangle')}
              >
                <div 
                  className="w-6 h-4 rounded-sm mx-auto" 
                  style={{ backgroundColor: theme === 'dark' ? 'var(--dark-node-2)' : 'var(--vibrant-node-2)' }}
                ></div>
                Rectangle
              </button>
              <button
                className={`px-3 py-1 rounded-lg ${selectedShape === 'square' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setSelectedShape('square')}
              >
                <div 
                  className="w-4 h-4 rounded-sm mx-auto" 
                  style={{ backgroundColor: theme === 'dark' ? 'var(--dark-node-2)' : 'var(--vibrant-node-2)' }}
                ></div>
                Square
              </button>
            </div>
          </div>
          
          <button
            className="w-full bg-gray-200 text-gray-700 px-3 py-1 rounded-lg"
            onClick={toggleSettings}
          >
            Close
          </button>
        </div>
      )}
      
      {/* Learning Path Panel */}
      {showLearningPath && (
        <div 
          className="absolute top-4 left-4 bg-white p-4 rounded-lg shadow-lg z-20 max-w-md max-h-[80vh] overflow-y-auto"
          style={{ 
            backgroundColor: theme === 'dark' ? 'var(--dark-node-1)' : 'white',
            color: theme === 'dark' ? 'white' : 'inherit'
          }}
        >
          <h3 className="text-lg font-semibold mb-4">Learning Path for {mindMap?.text}</h3>
          
          {learningPath ? (
            <div className="space-y-4">
              {learningPath.map((step, index) => (
                <div 
                  key={index} 
                  className="p-3 rounded-lg"
                  style={{ 
                    backgroundColor: theme === 'dark' ? 'var(--dark-node-2)' : 'var(--vibrant-node-2)',
                    marginBottom: '16px'
                  }}
                >
                  <h4 className="font-semibold text-white">{index + 1}. {step.title}</h4>
                  <p className="text-sm mt-1 mb-2" style={{ color: theme === 'dark' ? 'rgba(255,255,255,0.8)' : 'white' }}>
                    {step.description}
                  </p>
                  
                  {step.timeEstimate && (
                  <div style={{ 
                    fontSize: '13px', 
                    color: theme === 'dark' ? 'rgba(255,255,255,0.7)' : 'rgba(255,255,255,0.9)',
                    marginBottom: '8px' 
                  }}>
                    ⏱️ Estimated time: {step.timeEstimate}
                  </div>
                  )}
                  
                  {step.resources && step.resources.length > 0 && (
                    <div>
                      <strong style={{ fontSize: '13px' }}>Recommended Resources:</strong>
                      <ul style={{ margin: '4px 0 0 0', paddingLeft: '20px', fontSize: '13px' }}>
                        {step.resources.map((resource, i) => (
                          <li key={i}>{resource}</li>
                        ))}
                      </ul>
                    </div>
                  )}
                  
                  {step.milestones && step.milestones.length > 0 && (
                    <div>
                      <strong style={{ fontSize: '13px' }}>Milestones:</strong>
                      <ul style={{ margin: '4px 0 0 0', paddingLeft: '20px', fontSize: '13px' }}>
                        {step.milestones.map((milestone, i) => (
                          <li key={i}>{milestone}</li>
                        ))}
                      </ul>
                    </div>
                  )}
                  
                  {step.prerequisites && step.prerequisites.length > 0 && (
                    <div>
                      <strong style={{ fontSize: '13px' }}>Prerequisites:</strong>
                      <ul style={{ margin: '4px 0 0 0', paddingLeft: '20px', fontSize: '13px' }}>
                        {step.prerequisites.map((prerequisite, i) => (
                          <li key={i}>{prerequisite}</li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>
              ))}
            </div>
          ) : (
            <div className="text-center py-4">
              <div className="animate-spin mb-2">⟳</div>
              <p>Generating learning path...</p>
            </div>
          )}
          
          <button
            className="w-full bg-gray-200 text-gray-700 px-3 py-1 rounded-lg mt-4"
            onClick={toggleLearningPath}
          >
            Close
          </button>
        </div>
      )}
      
      <Stage
        ref={stageRef}
        width={window.innerWidth}
        height={window.innerHeight}
        onWheel={handleWheel}
        draggable
        x={position.x}
        y={position.y}
        scaleX={scale}
        scaleY={scale}
        onClick={closeContextMenu}
      >
        <Layer>
          {renderNodes(mindMap)}
        </Layer>
      </Stage>
      
      {/* Context Menu */}
      {contextMenu.visible && (
        <div
          className="context-menu absolute z-10"
          style={{
            top: contextMenu.y,
            left: contextMenu.x,
          }}
        >
          <div className="context-menu-item" onClick={handleExpand}>
            Expand
          </div>
          <div className="context-menu-item" onClick={handleCollapse}>
            {findNodeById([mindMap], contextMenu.nodeId || '')?.isCollapsed ? 'Uncollapse' : 'Collapse'}
          </div>
          {contextMenu.nodeId !== 'root' && (
            <div className="context-menu-item" onClick={handleDelete}>
              Delete
            </div>
          )}
        </div>
      )}
      
      {/* Node Action Modal */}
      <AnimatePresence>
        {modal.visible && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.2 }}
            className="absolute z-10 bg-white p-4 rounded-lg shadow-lg"
            style={{
              top: modal.y,
              left: modal.x,
            }}
          >
            <div className="mb-4">
              <button
                onClick={handleGenerateAINodes}
                className="w-full px-4 py-2 rounded-lg mb-2"
                style={{
                  backgroundColor: theme === 'dark' ? 'var(--dark-node-3)' : 'var(--vibrant-node-3)',
                  color: 'white'
                }}
              >
                Generate AI Nodes
              </button>
              <div className="text-center text-gray-500 my-2">or</div>
              <div className="flex">
                <input
                  type="text"
                  value={newNodeText}
                  onChange={(e) => setNewNodeText(e.target.value)}
                  placeholder="Enter node text"
                  className="flex-1 p-2 border-0 rounded-l-lg outline-none"
                  style={{ border: '1px solid var(--gray-300)' }}
                />
                <button
                  onClick={handleAddManualNode}
                  className="text-white px-4 py-2 rounded-r-lg"
                  style={{
                    backgroundColor: theme === 'dark' ? 'var(--dark-node-2)' : 'var(--vibrant-node-2)'
                  }}
                  disabled={!newNodeText.trim()}
                >
                  Add
                </button>
              </div>
            </div>
            <button
              onClick={closeModal}
              className="w-full bg-gray-200 text-gray-700 px-4 py-1 rounded-lg"
            >
              Cancel
            </button>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default Canvas;
